BBS(A): O(n^2)   stable, inplace
  for i in [0,|A|-2]:
    for j in [0,n-2-i]:
      if A[j]>A[j+1]:
        A[j],A[j+1]

ISS(A): O(n^2)   stable, inplace
  for i in [i,|A|-1]:
    j=i
    while A[j]<A[j-1] & j>0
      A[j],A[j-1]
      j--

SSS(A): O(n^2)   inplace
  for i in [0,|A|-1]
    min = i
    for j in [i+1,|A|-1]:
      if A[j] < A[min]:
        min = j
    if min != i:
      A[min],A[i]

HS(A):        O(n*log(n))  inplace
  buildMaxHeap(A)
  i = |A|-1
  while i >=0:
    A[0],A[i]
    bbd(A,0,i)
    i--

buildMaxHeap(A):
  for i [n/2,0]:
    bbd(A,i,n)

bbd(A,i,n):
  left = 2i+1, right = 2i+2, larget = i

  if left<n and A[largest] < A[left]
    largest = left
  if right <n and A[largest] < A[right]
    largest = right

  if largest != i:
    A[largest],A[i]
    bbd(A,largest,n)


removeMin(A):
  A[0]=A[n-1], i=0
  while 2i+2<n-1:
    min = A[2i+2]<A[2i+1]?2i+2:2i+1
    if A[min] < A[i]:
      A[min],A[i]
      i =min

  if 2i+1 < n-1 & A[2i-1]<A[i]:
    A[2i+1],A[i]


MS(A):        stable
  if |A| <= 1: return A
  i = |A|/2
  A1=MS(A[0,i-1])
  A2=MS(A[i,|A|-1])

  return merge(A1,A2)


merge(A1,A2):
  i,j = 0
  A = empty list
  while i < |A1| & j< |A2|:
    A[i+j] = A1[i]<A2[j] ? A1[i]; i++ : A2[j]; j++
  
  while i < |A1|
    A[i+j] = A[i]
    i++

  while j < |A2|
    A[i+j] = A[j]
    j++

  return A


QS(A,low,high):
  if low>=high: return A

  p = partition(A)
  QS(A,low,p-1)
  QS(A,p+1,high)

  return A

partition(A,low,high):
  p = high

  left = 0, right = high-1

  while left<=right:
    while left<|A| and A[left] < A[p]:
      left +=1

    while right>=0 and A[right] > A[p]:
      right -=1
    
    if left<right:
      A[left],A[right]
  
  A[left],A[p]
  return left


    
BS(A):
  N= antall kategory på elementene i A
  B = a nested list with N empty list

  for element in A:
    k = kategory til element
    add element to B[k]

  i = 0
  for b in B:
    for e in b:
      A[i] = e
      i++

  return A


Radix(A):
  d = siffer til det største tallet
  for i in [d,1]:
    bucketSort(A) based the ist siffer 
  return A



BFS(G,s,vstd):
  que = que contains only s
  while q:
    u = q.deque()
    if u not in vstd:
      add u to vstd
      for (u,nabo) in E:
        add nabo to que

BFSFull(G):
  vstd = empty set
  for v in V:
    if v not in vstd:
      BFS(G,v,vstd)


Topsort(G,s,vstd,stack)
  add s to vstd
  for (s,nabo) in E:
    if nabo not in vstd:
      Topsort(G,nabo,vstd,stack)
  stack.push(s)

TopsortFull(G)
  vstd, stack
  for v in V:
    if v not in vstd:
      Topsort(G,s,vstd,stack)
  return stack



  median1(A):
    vstd = {}, index=0
    while index != (i-1)/2:
      pivot=0
      while A[pivot] in vstd:
        pivot++
      index = partition(A,0,|A|-1,pivot)
      add A[pivot] to vstd

    return A[index]
